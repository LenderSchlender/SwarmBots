% Software Backend (Python)
% Zuständig: Jones

% wie/wo soll protobuf erklärt/erwähnt werden?

\chapter{Software - Backend}
\label{sec:software_backend}
\initials{JS}
Das Backend ist die zentrale Rechenstelle, 
welche in mehrere Komponenten aufgeteilt ist.
% generell zum backend

\begin{figure}[H]
    \includegraphics[width=\textwidth, center]{img/backend-konzept.png}
    \caption{Backend Konzept}
    \label{fig:backend_konzept}
\end{figure}
% grafik anpassen

Es ist verantwortlich für die Kommunikation und Datenerfassung 
zwischen allen Teilnehmern. 
Dazu gehören die drei Roboter, welche die Daten liefern wie LiDAR, 
Beschleunigungssensor etc., und das Frontend, 
zu dem die Daten zur Visualisierung und Mitverfolgung gesendet werden 
und von dem gegebenenfalls auch Befehle empfangen werden.
\\
Weiters findet hier die zentrale Datenverarbeitung und Verwaltung statt, 
diese ist verantwortlich für die Erstellung der LiDAR-Map, 
die Ermittlung der Roboterpositionen und gegebenenfalls die Berechnung der Messwerte. 
% im falle ineffizient etc
\\
Eine weitere Aufgabe des Backends 
ist die Steuerung der Roboter mithilfe eines Erkennungssystems, 
welches nach bestimmten Kennzeichen in den erhaltenen Daten Ausschau hält 
und darauf Kennzeichen für die einzelnen Bots erkennt und verfolgt, 
um entsprechend die Positionen aller Bots relativ zur LiDAR-Map ausfindig zu machen.
% 
% Die Zentrale Datenverarbeitung und autonome Steuerung der Roboter sind 
% im zu zeitigen Prototypen stand nicht implementiert.
% % stattdessen weiterleitung und fernsteuerung
% TODO 
\\
Letztendlich verwaltet das Backend die Datenbank, 
welche die etwaigen Daten der Datenverarbeitung und des Erkennungssystems speichert, 
dazu gehört insbesondere die LiDAR-Map.

Für die Programmierung des Backends wurde die Sprache Python gewählt, 
welche mit ihrer Vielzahl von Standardpaketen 
und großen Anzahl an externen Paketen 
und Frameworks eine effiziente und schnelle Programmierung unterstützt, 
auch durch eine aktive Community.
% 
Für dieses Projekt wurde es gewählt aufgrund seiner Vielseitigkeit, 
speziell in Bezug auf die unterschiedlichen Tasks, 
die ausgeführt werden müssen, 
hauptsächlich in Bezug auf Kommunikation und Datenverarbeitung, 
in denen Python üblicherweise verwendet wird.
% 
Dabei müssen auch mehrere Verbindungen offen bleiben und verwaltet werden, 
und diese wesentlichen Eigenschaften für einen Server 
schnell mithilfe von Paketen realisiert wurde. 
% 
Die uns ermöglichen, aufs wesentliche zu fokussieren.
% 
Effiziente Programmierung und Modifizierung ist wesentlich, 
weil der Backend-Code kontinuierlich wächst.
% 
Dies wurde auch durch Erfahrungen mit dem Vorgänger-Projekt untermauert, 
denn ein wesentlicher Teil davon bestand aus der Kommunikation über Websockets.
% Gelaber über python
% wegen math Funktionen...
% schnelle Modifizierung 
% packet/ Bibliothek Fokussierung auf Einfachheit
\section{Systembeschreibung}
\initials{JS}
% drunter verschoben weil besseres layout?
In diesem Abschnitt wird genauer 
über die geplanten einzelnen Komponenten 
und deren Funktion gesprochen.

Zu beachten ist, dass nicht alle geplanten Systeme, die hier beschrieben sind, 
implementiert wurden und manche noch in der Konzeptphase sind.
Für den tatsächlichen Stand siehe Abschnitt \ref{subsec:backend_aktueller_stand}.

\subsection{Datenverwaltung}
\label{subsec:backend_data}
\initials{JS}
% übersicht über die drei komponenten und wie ungefähr der datenfluss aussieht?
% TODO
% Datenbank für lidar?
% TODO

% TODO bevor abgabe
% womöglich löschen
Dieser Abschnitt bespricht kurz den Datenablauf 
zwischen den Teilnehmern und den internen Komponenten.
% 
Weil teile des Backends nicht realisiert sind ist ebenfalls 
die Datenverarbeitung nicht realisiert,
weswegen nicht viel weiter zur Verwaltung gesprochen werden kann.

\subsection{Kommunikation}
\label{subsec:Kommunikation}
\initials{JS}
Die drei Roboter sind aktive Teilnehmer in der Kommunikation, 
das heißt, die Verbindung ist permanent aufrechtzuerhalten, 
bidirektional und zeitlich synchronisiert. 

Zur Verbindung entschieden wir uns für das Kommunikations-Protokoll Websocket, 
dieses ermöglicht eine bidirektionale, 
persistente Verbindung zwischen Client und Server,
welche im Vergleich zu gewöhnlichen HTTP-Anfragen offen bleibt, 
wodurch Echtzeitkommunikation möglich ist.
% könnte man mehr ausschreiben aber schau ma später

Das Frontend und die Roboter kommunizieren hauptsächlich 
über Websockets mit den Protobufs.

\subsection{Datenverarbeitung}
\initials{JS}
% TODO
Eine Aufgabe des Servers ist die Verarbeitung der erhaltenen Daten, 
sowie die Weiterleitung zum Frontend.
% 
Um große Belastung durch die Auswertung von Sensordaten auf dem Roboter zu vermeiden, 
werden einige Arbeiten auf den Server ausgelagert.
Außerdem stehen in Python bereits ausgebaute Mathematik Pakete zur Verfügung 
um die Sensordaten zu bearbeiten 
ebenso wie Softwarepakete für Datenanalyse und -manipulation.


\subsection{Erkennungssystem}
\initials{JS}
Geplant war, dass aus den erhaltenen Daten mit der Zeit eine Karte erstellt wird, 
sozusagen die LiDAR-Map, 
welche in einer Datenbank abgespeichert wird.
% 
Über die Zeit werden Datenpunkte gesammelt, 
die sich nach einem gewissen Muster sammeln 
und ein klareres Bild über die Form eines Raumes geben.
Diese Muster, z.B. gerade Linien und Ecken, werden vom System erkannt 
und mit diesen Eigenschaften auch ermittelt, 
wo ungefähr sich der Guide im Raum befindet.
% 
Dies wird mit einem weiteren Erkennungssystem für Tamerlan \& Bambi kombiniert, 
welches zuständig ist, die Position der beiden zu ermitteln,
indem auf den Bots identifizierbare reflektieren Objekte befestigt werden, 
beispielsweise Zylinder, wodurch sie erkannt werden können.
%
Mit diesen Informationen kann die Steuerung der Roboter folgen.
% füge skizzen hier oder erklär anderen Kapitel?
% Kugel, stab, mehrere stäbe, reflektierendes material

Eine genauere Beschreibung der LiDAR Karte und wie diese aussieht, 
ist im Frontend Abschnitt \ref{subsec:frontend_lidar_map} 
auf Seite \pageref{subsec:frontend_lidar_map} zu finden.

\subsection{Steuerung der Roboter}
\label{subsec:backend_robot_detection}
\initials{JS}
% TODO
Zurzeit nicht realisiert.
% spätester schritt weil funktionierende Strategie benötigt wird zur Erkennung
% Datenbank/ Datenbearbeitung

Die Aufträge der einzelnen Bots 
sind in den entsprechenden Kapiteln genauer beschrieben.
% schau was da steht und was speziell hier klargemacht werden muss

Es sind zwei Steuerungen geplant, 
die manuelle Steuerung und die automatisierte.
% 
Die manuelle Steuerung geschieht über das Frontend, 
womit man die Roboter mithilfe der Visualisierungen 
und oder Videoübertragung steuern kann.
% 
Die automatisierte Steuerung geschieht mithilfe des Erkennungssystems 
und soll den Bots erlauben, die erstellte LiDAR Karte zu navigieren 
und erlauben den zwei blinden Bots Tamerlan \& Bambi, dem Guide zu folgen.
% verwendung von code vom vorgänger Projekt

\section{Aktueller Stand}
\label{subsec:backend_aktueller_stand}
\initials{JS}
% Womöglich Teile zu Ergebnisse verschieben?
Zum Zeitpunkt dieser Diplomarbeitsabgabe 
sind nicht alle geplanten Features für das Backend implementiert,
Wodurch der Großteil der Backendserver-Seite nicht realisiert werden konnte.

Zur Überbrückung wurde der Kommunikationsteil so realisiert, 
dass es als Weitergabe fungiert.
Dies wurde so realisiert, dass die Daten 
zwischen einem Bot und dem Server weitergegeben werden, essenziell ein Router. 
Der nächste Schritt besteht dann, über eine Prototyp Steuerung 
Befehle zu den einzelnen Bots zu senden.

Die Prototyp Steuerung ist realisiert als eine manuelle Steuerung, 
wo der gewählte Roboter manuell von einem User bedient wird.
In Zukunft kann die manuelle Steuerung als eine weitere Option beibehalten werden, 
die die automatisierte Steuerung überschreiben kann. 
Dies kann verwendet werden, 
um beispielsweise den Guide manuell in bestimmte Bereiche zu führen,
andernfalls auch für Test und Debugging, 
sowie um eine neue Datenerfassung zu erzwingen.

\section{Backend - Code}
\initials{JS}
In diesem Abschnitt wird genauer auf den Code des Backend Prototyps eingegangen 
und auf dessen technische Realisierung. 
Weiters wird auch beschrieben, welche Pakete und Werkzeuge verwendet wurden. 

\subsection{Zusätzlich verwendete Tools und Workflow}
\initials{JS}
% algemein zu python workflow
% womöglich unötig
% TODO
\subsubsection{Formatter und Linter} 
\initials{JS}
Um gute Lesbarkeit zu gewährleisten, 
ist eine ordentliche Struktur und Formatierung in jedem Code notwendig, 
jedoch ist es schwierig, eine gute Konsistenz beizubehalten, 
weshalb Formatierungstools und Linters häufig Verwendung finden. 
% 
Linters sind Tools, welche automatisch den Code überprüfen, 
um stilistische Fehler und Einhaltung von Codierung Standards sicherzustellen.
Dies soll helfen, die Code-Qualität zu verbessern 
und eventuelle Fehler frühzeitig zu erkennen.

Die Standard-Erweiterung für Python von Visual Studio Code 
beinhaltet kein Formatierungstool.
Dafür wurde der Formatter \texttt{autopep8} verwendet, 
weil er die Eigenschaft hat, den Originalstil des Schreibers beizubehalten
und nur Änderungen für die Lesbarkeit durchzuführen. 
Dazu passend ist der Linter \texttt{Flake8}, welcher standardmäßig 
dem gleichen Styleguide \text{PEP 8} folgt.
% weil vscode es standart mäßig Formatierung nicht mitliefert
% \subsubsection{venv/environment management}
% \initials{JS}
% % TODO
% Falls sich nicht viel ändert, ist dieser Abschnitt wahrscheinlich nicht nötig, 
% da nicht viel besonders ist.


\subsection{Python Packages}
\initials{JS}
% TODO schau dir dieses abschniit nochmal durch
Um gegebene Funktionen zu gewährleisten, sind weitere externe Pakete nötig, 
die nicht Teil der Standardpakete sind.
Welche zu diesem Stand verwendet wurden, ist in diesem Abschnitt erklärt.

\subsubsection{websockets}
\initials{JS}
Für Python ist ein Websocket Paket namens 'websockets' vorhanden, 
welches die Client-Server Kommunikation um ein Vielfaches vereinfacht, 
da man sich keine Sorge über Handshakes, Ping Pongs, 
oder anderes Verhalten der Websocket Spezifikation machen muss, 
da es alles von dem Paket behandelt wird 
und man sich mehr auf die Applikation fokussieren kann. 
Es sind dennoch einige Parameter zur Verfügung gestellt, 
um das Verhalten zu modifizieren.
% code beispiele?

% erklärung zu den packet Webscoket
Websockets Standard Implementierung basiert auf asyncio.
%  
Asyncio ist die eingebaute Implementierung von Co-Routinen in Python,
dies erlaubt das Schreiben von asynchronen Frameworks, 
öfters verwendet für I/O-limitierte Netzwerk Codes.
% snippet zu asyncio, könnte mehr schreiben?
Alternative ist eine threading Implementierung verfügbar für Websockets, 
die üblichere Implementierung von mehreren Tasks, 
jedoch wurde für den derzeitigen Entwicklung-Stand dagegen entschieden,
aufgrund der möglichen erweiterten Komplexität von Thread-sicherer Code-Ausführung.
% warum nicht? kann später bei optimierungsmöglichkeiten erklärt werden
Eine Sans-I/O Implementierung ist auch vorhanden, 
jedoch für dieses Projekt zurzeit irrelevant.

\subsubsection{protobuf}
\initials{JS}
Das Besondere an der protobuf Implementierung hier in Python ist,
dass sehr viel von dem protobuf Paket selbst erledigt wird.
Im Vergleich zum Vorgänger Projekt, wo die Datenpakete manuell hergerichtet werden
und zum richtigen Byte Format konvertiert werden mussten, 
wird mit Protobuf ein Objekt erstellt 
und jeweils die gegebenen Variablen angesprochen, 
diese mit einem einzelnen Befehl ins Sende-Format konvertiert und umgekehrt.
% verhalten in python
% wie anders

% Kurzeitig gab es das Problem wie genau mit dem protobuf paket zu arbeiten ist,
% aufgrund dessen das die dokumentation nicht der von anderen Python Paketen gleicht
% und alle Informationen hauptsächlich von der Anleitungen zu Wünschen übrig lässt.
% Ich hatte einfach ein wenig probleme es anfänglich zu kapieren aber ging schnell

\subsection{Prototyp Kommunikation - test\_server\_passby.py}
\initials{JS}
In diesem Abschnitt wird über den zu zeitigen Prototyp der Kommunikation 
und bestimmte technischen Implementierungen angesprochen.

Der Prototyp hat die Funktion, zwei Typen von Verbindungen zu bearbeiten.
% 
Einerseits die der Bots, welche als Server agieren, 
dies Bedeuten, dass dieser Backend Server muss sich mit den drei Robotern verbinden.
Während das Frontend standardmäßig als Client fungiert, 
dies Bedeutet, dass die Clients eine Verbindung mit dem Backend Server herstellen.
% 
Andererseits die Verbindung mit dem Frontend, 
welche vom Server für einkommende Verbindungen bereitgestellt werden muss.
% 
Die Daten, die von der jeweiligen Seite kommen, 
werden zurzeit zur gegenseitigen Stelle weitergeleitet.

Dementsprechend ist die Kommunikation auf zwei Tasks aufgeteilt,
die des Frontends und die der Roboter.
Beide Tasks starten einen weiteren Subtask, welcher nebenbei laufen wird, 
dieser hat entsprechend die Aufgabe, solange die Websocket Verbindung offen ist,
die ankommenden Pakete erwartet und diese entsprechend in eine Queue Puffer ablegt, 
um weiter verarbeitet zu werden. 

Beide Tasks verarbeiten die Queues, 
in denen eine bestimmte Anzahl der Elemente im Puffer 
einzeln geholt und die Protobuf Wrapper verarbeitet werden.
% 
Im zum zeitigen Prototyp werden die Daten in die Konsole ausgegeben,
und zur Sendung der Gegenseite in eine weitere Queue 
für einen beliebigen Roboter bereitgestellt, 
oder im Fall beim zum zeitigen Roboter-Handler 
an alle verbundenen Frontends gesendet.
% 
Dies symbolisiert in den nächsten Iterationen die Weitergabe 
in die Datenbank und Datenverarbeitung.

% übersichtsgrafik über teilnehmer und wie datenablauf funktioniert
% asyncio - warum
% main task überblick (server und drei clients) warum so aufgeteilt?
% subtask

\subsubsection{asyncio}
\initials{JS}
% erklärung zu asyncio
Um mehrere separate Tasks auszuführen wurde Asyncio,
die eingebaute Implementierung von Koroutinen in Python verwendet.
% 
Asyncio funktioniert, indem Tasks sich den Event Loop nehmen und mit dem 'await' 
Befehl anderen Tasks erlaubt, sich den Event Loop zu nehmen, 
im Vergleich zu üblichem Multitasking,
wo jeder Task eine feste Zeit vom Betriebssystem zugeschrieben bekommt.

TODO Womöglich weiter beschreiben, wie asyncio genau funktioniert?

\subsubsection{Queue Buffers}
\initials{JS}
% FIFO Queues
% Wichtigkeit nicht blockierendes verhalten um asynchrones workflow zu gewährleisten
Damit die Prozesse im Backend nicht gezwungen sind, immer zu bearbeiten, 
wenn und falls Einkommen Nachrichten zu bearbeiten sind, 
wird der Empfang von Websockets abgekoppelt von der backend Logik.
Dafür wurden Queues, realisiert als FIFO, verwendet, also ein zwischen speicher, 
wo die erhaltenen Daten von den Websockets landen, 
um dann entsprechen weiter zu bearbeiten.
% 
Somit können wir einen Prozess starten, 
welcher auf eingehende Nachrichten warten kann,
während unser Backend andere Prozesse ausführt.
% kann mehr dazu schreiben
% ermöglicht auch sachen etc.
% TODO

\subsection{Prototyp manuelle Steuerung}
\initials{JS}
Die Prototyp Steuerung soll einem Bediener erlauben, manuell den Bot zu steuern,
indem wir mit einer Eingabe bewegen können. 
% 
Dafür verwenden wir einen Controller, 
aufgrund dessen, dass wir bereits im Vorgängerprojekt
eine Form solcher Steuerung realisiert haben. 
Deshalb ist ein Großteil der Arbeit hier die Anpassung an das neue Datenformat, 
Verwendung neuer Websocket Pakete und Modifizierung der Berechnungen.
% 
Anfänglich ist geplant, es als einzelnes Skript zu realisieren, 
welches den Platz des Frontends nimmt, 
und im Laufe des Projekts ins Frontend integriert oder neu implementiert wird.

% TODO aktualisiere dies entsprechend
Zum Zeitpunkt des Schreibens dieses Abschnitt der Diplomarbeit 
ist dies mitten in der Bearbeitung.
% TODO
\subsubsection{Vorgänger Code}
\initials{JS}
Erklärung, was der alte Code alles macht.
\subsubsection{Anpassung}
\initials{JS}
Wie es angepasst wurde.

\subsection{Konsolen Ausgabe}
\initials{JS}
% siehe print_wrapper_content.py
Der Skript \texttt{print\_wrapper\_content.py} hat die simple Funktion, 
die Daten von einem Protobuf Wrapper in die Konsole auszugeben, 
in eine einfache Menschlich lesbare Struktur. 
Hauptsächlich genutzt für Debug und Entwicklungsschritte.

\begin{figure}[H]
    \includegraphics[width=0.5\textwidth, center]{img/Backend/print_wrapper_all.png}
    \caption{Python - Protobuf Konsolen Ausgabe}
    \label{fig:py_konsole_o}
\end{figure}

In Zukunft kann dies durch die Datenbank oder ein CSV Log abgelöst werden 
und somit auch bessere Systeme implementiert werden.
% 
Diese könnten automatisch für sonderbare Änderungen suchen 
und entsprechend melden und in einem Log abspeichern.

\section{Protobuf Generierung}
\initials{JS}
% TODO
Zurzeit nicht implementiert.

Ein kleines Skript, welcher die Protobuff Dateien generiert
und die Imports richtig setzt. 

\section{Konfiguration Datei}
\initials{JS}
% TODO 
Zurzeit nicht implementiert.

Bestimmte Konfigurationen wie die Roboter Adressen 
sollten in einer eigenen Konfigurations Datei landen und nicht im Code gesetzt sein.


\subsection{Optimierungsmöglichkeiten}
\initials{JS}
\label{subsec:Optimierungsmöglichkeiten}
\subsubsection{uvloop - schnellere Koroutinen}
\initials{JS}
% uvloop - drop in replacement
% https://github.com/MagicStack/uvloop
uvloop ist ein schneller drop-in Ersetzung von der eingebauten asyncio Event Loop, 
dieser ist entsprechend in Cython entwickelt 
(Cython ist entsprechend Python, aber als Performanten C code compiliert).
Ziel dieser Ersetzung ist es, asyncio um einiges schneller zu machen, 
aber nicht von der Referenz verhalten von asyncio abzuweichen. 
Als drop-in Ersetzung geht dies so weit, 
dass die Abweichungen als Fehler kategorisiert werden.
% 
Während der Prototyp Phase dieses Projekts 
ist man auf der Standard Implementierung geblieben, aufgrund Stabilität
und weil uvloop bis später im Projekt unbekannt geblieben ist.
In Zukunft wird jedoch eine Implementierung in Betracht gezogen,
aufgrund der vorhin genannten Eigenschaften.
% 
Insbesondere, wenn die nachfolgenden Projekte weiter skalieren.

% compelierung python code
\subsubsection{Kompilierung}
\initials{JS}
Es ist möglich, Python Code genauso wie jedes andere Programm zu kompilieren,
jedoch ist dies standardmäßig nicht nötig, 
da der Interpreter Cpython automatisch Python byte code kompeliert (in PYC Dateien).
Das prekompilieren wird hauptsächlich dafür verwendet, 
um die Startzeit zu verringern 
und um den Code für die gewählte Platform einfacher zu verteilen,
weil man keine weiteren Pakete installieren muss, 
sondern nur die PYC Datei allein genügt.
% Dies ist jedoch für dieses Projekt irrelevant.

\subsection{threading vs asyncio}
\initials{JS}
% TODO threading warum nicht streng nötig 
% (hauptsächlich limitiert über Wifi I/O nicht anzahl an geräten & )
% falls anzahl größer wird dann villeicht
Unsicher, ob dieser abschnitt nötig ist.

\section{Probleme}
\initials{JS}
\subsection{Linux Modifikationen}
\initials{JS}
Es kam das Problem auf, 
dass die lokale IP suche auf Linux Ubuntu nicht funktionierte.
Dies lag daran, dass die vorherige Variante, 
welche mithilfe der Domain Name auf die lokale IP-Adresse findig wurde.
Jedoch wurde auf Linux eine andere Adresse zurückgeliefert, 
zwar die Loopback-Adresse \texttt{127.0.1.1}. 
Diese Adresse wird verwendet, um dem \texttt{host\_name} eine Adresse zuzuweisen,
im Falle, dass kein Netzwerk vorhanden ist. 
Sonst kann eine permanente IP-Adresse hier zugewiesen werden.
% https://askubuntu.com/questions/754213
% /what-is-difference-between-localhost-address-127-0-0-1-and-127-0-1-1

Als Lösung öffnet das Programm temporär ein Socket 
und findet mit dieser die lokale IP-Adresse, und dadurch Plattform unabhängig.
\begin{lstlisting}[language=python, gobble=4]
    import socket

    def get_local_ip():
    """
    opens a temporary socket connection and retrieves the local IP
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # doesn't even have to be reachable
        s.connect(('10.255.255.255', 1))
        IP = str(s.getsockname()[0])
    except Exception as b:
        print("error at figuring out local ip")
        print(b)
        exit
    finally:
        s.close()
    return IP
\end{lstlisting}

\subsection{Potenzielles blockierendes verhalten}
\initials{JS}
% bot_handler und server nicht separat gestartet werden.
Obwohl die Kommunikation in hauptsächlich zwei Teile aufgeteilt ist, 
mit Bot-Handler und Server, 
jedoch werden sie zu diesem Zeitpunkt gesammelt und gemeinsam gestartet.
Dies führt zu einer womöglich ungewollten Konsequenz,
dass, falls der Bot-Handler sich frühzeitig oder ungewollt beendet, 
nicht neu gestartet wird, bis sich einen neuer Client verbindet.
% 
Da jedoch für diese Diplomarbeit zu erwarten ist, 
dass die Bots stets zur Verfügung stehen sollten,
wird der Prozess, bei einer geschlossenen Verbindung,
für eine gewisse Zeit pausiert, bevor ein neuer Verbindungsversuch gestartet wird.

In den nächsten Iterationen sollten jedoch 
die zwei Aufträge unabhängig gestartet werden können, 
um die Situation zu vermeiden, 
dass die ganze Kommunikation neu gestartet werden muss.

\subsection{Protobuf Generierung}
\initials{JS}
% siehe server/README.md
% verlege zu Backend probleme?
Während des migrieren vom Vorentwicklungsordner, 
aufgrund dessen, dass es noch nicht klar war, wie mit Protobuf 
und der neuen Websocket Implementation zu hantieren ist, 
wurde für eine gewisse Zeit in einem Testordner experimentiert.
Dies führte dazu, dass der generierte Protobuf code nicht funktionierte,
da der Wrapper nicht über den Unterordner Standort \text{protobuf/}, 
der weiteren Protobuf-dateien informiert wurde.
Da das Kompilieren der Protobuf Dateien für Python unabhängig vom Standort
der Python Umgebung geschieht. 
Wodurch die Importe im generierten \text{wrapper\_pb2.py}
mit dem Ordner vorangestellt werden müssen.

\begin{lstlisting}[language=python, gobble=4]
    import protobuf.move_cmd_pb2 as move__cmd__pb2
    import protobuf.led_cmd_pb2 as led__cmd__pb2
    import protobuf.lidar_data_pb2 as lidar__data__pb2
    import protobuf.encoder_data_pb2 as encoder__data__pb2
    import protobuf.imu_data_pb2 as imu__data__pb2
\end{lstlisting}


\section{Test Codes}
\initials{JS}
Es wurden weitere allgemeinere Test Codes geschrieben, 
welche die Funktion dienten, die Kommunikationskanäle und Datenbearbeitung innerhalb 
und außerhalb des Backends zu testen und gegebenenfalls 
von anderen Teammitgliedern modifiziert.
% 
Aber auch für die Fehlersuche 
und sind im Allgemeinen eine schnelle Option, 
um die Kommunikation und Datentausch zu testen.

Diese Codes haben große Ähnlichkeiten mit der Prototyp Kommunikation, 
deshalb wird in diesem Abschnitt hauptsächlich auf deren Nutzen eingegangen.

\subsection{Einzelverbindung - Robot\_ws\_test.py}
\initials{JS}
Dieser Testcode ist verantwortlich, sich mit den Bots zu verbinden 
und dessen Daten zu lesen.
Es wurde mit einigen Konfigurationen erweitert und modifiziert 
und wird im Laufe des Projekts angepasst, wenn nötig.
Zurzeit wurde es bereits verwendet, um die Kommunikation zu testen, 
die Bearbeitung von erhaltenen Daten vom Bot und generelle Fehler suche.

\subsection{Client und Server}
\initials{JS}
Dazu gehören \texttt{test\_wrap\_client.py} (als das Frontend) 
und \texttt{test\_wrap\_bot\_transceiver.py} (als die Bots).
Diese sind einfache Codes, welche Client uns Server (Bots und Server) emuliert, 
indem sich beide Protobuf Pakete zueinander schicken. 
Diese dienen hauptsächlich zum Testen der Websocket Kommunikation 
und auch zur Übung, wie Protobuf in Python zu verwenden sind, 
und nehmen die Position des Frontends und Bots.
Die zwei Senden und Empfangen die Protobuf Wrapper über die Backend Kommunikation 
und geben diese in die Konsole aus.
