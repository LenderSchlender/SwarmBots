% Software Backend (Python)
% Zuständig: Jones

% wie/wo soll protobuff erklärt/erwähnt werden?

\chapter{Software - Backend}
\label{sec:software_backend}
Das Backend ist die Zentrale Rechenstelle welches in drei Komponenten aufgeteilt.
% generell zum backend

\begin{figure}[H]
    \includegraphics[width=\textwidth, center]{img/backend-konzept.png}
    \caption{Backend Konzept}
    \label{fig:backend_konzept}
\end{figure}
% grafik anpassen

Wodurch es verantwortlich für die Kommunikation und Datenerfassung zwischen allen Teilnehmer. 
Dazu gehören die drei Roboter, welche uns die Daten liefern wie LiDAR, Beschleunigungssensor etc., 
und das Frontend zu dem die Daten zur Visualisierung und Mitverfolgung gesendet werden 
und gegebenenfalls auch Befehle empfingt.

Weiters findet hier die Zentrale Datenverarbeitung und Verwaltung statt, 
dies ist verantwortlich für die Erstellung der LiDAR Map, 
der Ermittlung der Roboter Positionen 
und gegeben falls Berechnung der Messwerte. 
% im falle ineffizient etc

Und Steuerung der Roboter mithilfe eines Erkennungssystems 
welches bestimmte Kennzeichen in den erhaltenen Daten Ausschau hält und 
darauf Kennzeichen für die einzelnen Bots erkennt und verfolgt, 
um entsprechend die Positionen aller Bots relativ zur LiDAR Map ausfindig zu machen.

Die Zentrale Datenverarbeitung und autonome Steuerung der Roboter sind 
im zu zeitigen Prototypen stand nicht implementiert.
% stattdessen weiterleitung und fernsteuerung
TODO 

TODO (Datenbank, Lidarmap)


Für das Backend wurde Python gewählt, 
welches von seiner Vielzahl von Standortbibliotheken und 
großen Anzahl an externen Bibliotheken und Frameworks, 
eine effiziente und schnelle Programmierung ermöglicht, 
auch unterstützt durch eine aktive Community.
% 
Für dieses Projekt wurde es gewählt aufgrund seiner Vielseitigkeit, 
speziell im Bezug auf den unterschiedlichen Task die ausgeführt werden müssen, 
insbesondere der Kommunikation und Datenverarbeitung 
Felder in die Python üblicherweise verwendet werden.
% 
Darauf müssen auch mehrere Verbindungen offen bleiben und verwaltet werden,
und dies schnell zu realisieren mithilfe von Bibliotheken 
die uns ermöglichen aufs wesentliche zu fokussieren.
% 
Eine schnelle Programmierung und Modifizierung, 
weil das Backend voraussichtlich mit dem zum zeitigen Projektstand wächst, 
ganz wichtig für die Datenverarbeitung und Steuerung da diese sich im Laufe des Projekts stark ändern kann,
aufgrund dessen, dass die Methoden und Systeme nicht endgültig feststehen, 
und teilweise noch definiert werden müssen.
% 
Und letzteres auch wegen Erfahrungen mit dem Vorgänger Projekt, 
denn ein wesentlicher Teil davon bestand auf die Kommunikation über Websockets.
% Gelaber über python
% wegen math Funktionen...
% schnelle Modifizierung 
% packet/ Bibliothek Fokussierung auf Einfachheit

\section{Datenverwaltung}
\label{subsec:backend_data}
% übersicht über die drei komponenten und wie ungefähr der datenfluss aussieht?
TODO
% Datenbank für lidar?
TODO

\section{Kommunikation}
\label{subsec:Kommunikation}
Die drei Roboter sind aktive Teilnehmer in der Kommunikation, 
das heißt es ist zu erwarten, dass die Verbindung konstant aufrechtzuerhalten ist,
bidirektional und dies auch in einem zeitlichen verhalten geschieht. 
Insofern muss weiter sichergestellt werden das ein konstanter Kommunikationsfluss ermöglicht bleibt.

Zur Verbindung entschieden wir uns für das Kommunikations-Protokoll Websocket, 
diese ermöglicht eine bidirektionale, persistente Verbindung zwischen einem Client und einem Server,
welches im Vergleich zu gewöhnlichen HTTP-Anfragen offen bleibt, wodurch Echtzeitkommunikation möglich ist.
% könnte man mehr ausschreiben aber schau ma später

\section{Datenverarbeitung}
Zurzeit nicht realisiert.

Geplannt war das die erhaltenen daten über das Datenverarbeitungsystem 
über die zeit hinaus eine Karte erstellt sozuagen die LiDAR map,
welche in einer Datenbank abgespeichert werden.

Dazu ein Erkennungssystem welche die einzelnen Roboter ausfindig machen soll.
Dafür haben wir einige Konzepte erstellt:
% füge skizzen hier oder erklär anderen Kapitel?
% Kugel, stab, mehrere stäbe, reflektierendes material

\section{Steuerung der Roboter}
\label{subsec:backend_robot_detection}
Zurzeit nicht realisiert.
% spätester schritt weil funktionierende Strategie benötigt wird zur Erkennung
% Datenbank/ Datenbearbeitung

Die aufträge der einzelnen Bots sind in den Entsprechenden Kapitel genauer beschrieben.
% schau was da steht und was speziell hier klargemacht werden muss

Stattdessen ein Test Programm zur Überprüfung zur theoretischen Steuerung.
% verwendung von code vom vorgänger Projekt

\section{Aktueller Stand}
Zum zeitpunkt dieser Diplomarbeits Abgabe sind nicht alle geplanten Features zeitlich zusammengekommen.
Wodurch der großteil der Backend Server Seite nicht realisiert werden konnte.

Zur Überbrückung wurde der Kommunikationsteil so realisiert das es als Weitergabe fungieren soll.
Dies wurde so realisiert das Daten zwischen einem Bots und dem server weitergegeben werden, 
essenziell ein Router. 
Der nächste schritt besteht dann über eine Prototyp Steuerung 
Befehle zu den einzelnen Bots zu senden.

Die Prototyp Steuerung ist realisiert als eine manuelle Steuerung, 
wo dem gewählten Roboter manuell von einem Bediener bedient.
In Zukunft kann die manuelle Steuerung als eine weitere Option beibehalten werden, 
die die Automatisierte Steuerung überschreiben kann. 
Dies kann verwendet werden um Beispielweise den Guide manuell in bestimmte Bereiche zu führen.
Anderes falls auch für Test und Debug Zwecke, sowie manuell eine neue Datenerfassung zu erzwingen.

\section{Backend - Code}
In diesem Abschnitt wird genauer zum Code des Backend Prototyps eingegangen 
und dessen Technischen Realisierung. 
Was genau die einzelnen Teile des Backends zu erledigen haben, 
wie diese Probleme bewältigt und realisiert wurden.
Weiters beschrieben welche Bibliotheken und werkzeuge verwendet wurden 

\subsection{zusätzlich verwendete tools/ workflow?}
% algemein zu python workflow
% womöglich unötig
\subsubsection{linter/formatter} 
% weil vscode es standart mäßig Formatierung nicht mitliefert
\subsubsection{venv/environment management}



\subsection{Protobuf files}
% siehe server/README.md
% verlege zu Backend probleme?

\subsection{Python Packages}
Um gegebene Funktionen zu gewehrleisten sind weitere externe Bibliotheken nötig, 
die nicht teil der standard Bibliotheken sind.
Welche zu diesen Stand verwendet wurden ist in diesem Abschnitt erklärt.

\subsubsection{websockets}
Für Python ist ein Websocket Paket namens 'websockets' vorhanden welches die Client-Server Kommunikation
um ein Vielfaches vereinfacht da man sich keine Sorge über Handshakes, Ping Pongs, oder anderes verhalten
der Websocket Spezifikation, da es alles von dem Paket behandelt wird 
und man sich mehr auf die Applikation fokussieren kann. 
Es sind dennoch einige Parameter zum zur Verfügung gestellt zur Modifizierung, falls benötigt.
% code beispiele?

% erklärung zu den packet Webscoket
Websockets Standard Implementierung basiert auf asyncio.
%  
Asyncio ist die eingebaute Implementierung von Koroutinen in Python,
dies erlaubt das Schreiben von asynchronen Frameworks, 
öfters verwendet für I/O limitierte Netzwerk Codes.
% snippet zu asyncio, könnte mehr schreiben?
Alternative ist eine threading Implementierung verfügbar für Websockets, 
die üblichere Implementierung von mehreren Tasks, 
jedoch haben wir uns für den zum zeitigen Prototyp Entwicklung-Stand dagegen entschieden,
aufgrund der möglichen erweiterten Komplexität von Thread sicheren code Ausführung.
% warum nicht? kann später bei optimierungsmöglichkeiten erklärt werden
Eine Sans-I/O Implementierung ist auch vorhanden jedoch für dieses Projekt zurzeit irrelevant.

\subsubsection{protobuff}
Das besondere an der protobuff implementierung hier in Python ist,
das sehr viel von der protobuff Bibliothek selbst erledigt wird.
Im vergleich zum vorgänger Projekt wo die Datenpakete manuell hergerichtet werden
und zum richtigen byte format konvertiert, wird mit Protobuff ein Objekt erstellt 
und jeweils die gegebenen Variablen angesprochen, 
diese mit einem einzelnen Befehl ins sende Format formatiert und genauso zurück
und von den gegebenen Tasks weiterverarbeitet werden kann.
% verhalten in python
% wie anders

% Kurzeitig gab es das Problem wie genau mit der mit dem Python protobuff paket zu arbeiten ist, 
% aufgrund dessen das die dokumentation nicht der von anderen Python Packeten gleicht
% und alle Informationen hauptsächlich von der Anleitungen zu Wünschen übrig lässt.
% Ich hatte einfach ein wenig probleme es anfänglich zu kapieren aber ging schnell

\subsection{Prototyp Kommunikation - test\_server\_passby.py}

% übersichtsgrafik über teilnehmer und wie datenablauf funktioniert
% asyncio - warum
% main task überblick (server und drei clients) warum so aufgeteilt?
% subtask


\subsubsection{asyncio}
% erklärung zu asyncio
Asyncio funktioniert, indem Tasks sich den Event loop nehmen und mit dem 'await' 
Befehl anderen tasks erlaubt sich den event loop zu nehmen, im vergleich zu üblichen multitasking
wo jeder task eine feste zeit zugeschrieben bekommt vom Betriebsystem.

TODO

\subsubsection{Queue Buffers}
% FIFO Queues
% Wichtigkeit nicht blockierendes verhalten um asynchrones workflow zu gewährleisten
Damit die Prozesse im Backend nicht gezwungen sind immer zu bearbeiten, 
wenn und falls Einkommen Nachrichten zu bearbeiten sind, 
wird der Empfang von Websockets abgekoppelt von den backend Logik.
Dafür wurden Queues, realisiert als FIFO, verwendet, also ein zwischen speicher 
wo die erhaltenen Daten von den Websockets landen, um dann entsprechen weiter zu bearbeiten.
Somit können wir einen Prozess starten, welches auf eingehende Nachrichten warten kann, 
während unser Backend andere Prozesse ausführt.
% kann mehr dazu schreiben
% ermöglicht auch sachen etc.

\subsection{Prototyp Manuelle Steuerung}
Die Prototyp Steuerung soll ein Bediener erlauben Befehle zu Bot zu senden

\subsection{Konsolen Ausgabe}
% siehe print_wrapper_content.py

\subsection{Optimierungsmöglichkeiten}
\label{subsec:Optimierungsmöglichkeiten}
% uvloop - drop in replacement
% https://github.com/MagicStack/uvloop
uvloop ist ein schneller drop-in Ersetzung von der eingebauten asyncio event loop, 
dieser ist entsprechend in Cython entwickelt (Cython ist entsprechend Python aber als Performanten C code compiliert).
Ziel dieser Ersetzung ist es asyncio um einiges schneller zu machen aber nicht von der Referenz verhalten von asyncio abzuweichen. 
Als drop-in Ersetzung geht dies so weit dass, die Abweichungen als Fehler kategorisiert werden.
% TODO threading warum nicht streng nötig 
% (hauptsächlich limitiert über Wifi I/O nicht anzahl an geräten & )
% falls anzahl größer wird dann villeicht
% compelierung python code
Es ist möglich Python code genau so wie jedes andere Programm zu kompilieren,
jedoch ist dies standardmäßig nicht nötig da der Interpreter Cpython automatisch Python byte code kompeliert (in PYC Dateien).

\subsection{Probleme}
\subsubsection{Linux Modifikationen}
Es kam das Problem auf, dass die locale IP suche auf Linux ubuntu nicht funktionierte.
Dies lag daran das die vorherige Variante 
mit Hilfe der Domain name auf die lokale IP Adresse findig wurde.
Jedoch wurde auf Linux eine andere Adresse zurückgeliefert, 
zwar die Loopback Adresse \texttt{127.0.1.1}. 
Diese Adresse wird verwendet um den host\_name eine Adresse zu zuweisen,
im Falle das kein Netzwerk vorhanden ist. 
Sonst kann eine permanente IP Adresse hier zugewiesen werden.
% https://askubuntu.com/questions/754213/what-is-difference-between-localhost-address-127-0-0-1-and-127-0-1-1

Als Lösung öffnet das Programm temporär ein Socket und findet mit der die locale IP Adresse.
\begin{lstlisting}[language=python, gobble=4]
    import socket

    def get_local_ip():
    """
    opens a temporary socket connection and retrieves the local IP
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # doesn't even have to be reachable
        s.connect(('10.255.255.255', 1))
        IP = str(s.getsockname()[0])
    except Exception as b:
        print("error at figuring out local ip")
        print(b)
        exit
    finally:
        s.close()
    return IP
\end{lstlisting}

\section{Test Codes}
Es wurden weitere allgemeinere Test Codes geschrieben, 
welche die Funktion dienten, die Kommunikation Kanäle und Daten Bearbeitung innerhalb 
und außerhalb des Backends zu testen und gegebenenfalls von anderen Team mitglieder modifiziert.
Diese Codes haben große Ähnlichkeiten mit der Prototyp Kommunikation, 
deshalb wird in diesem Abschnitt hauptsächlich auf dessen Funktion eingegangen.