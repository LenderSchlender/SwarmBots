% Software Backend (Python)
% Zuständig: Jones

% wie/wo soll protobuff erklärt/erwähnt werden?

\chapter{Software - Backend}
\label{sec:software_backend}
Das Backend ist die Zentrale Rechenstelle welches in drei Komponenten aufgeteilt.
% generell zum backend

Weshalb es verantwortlich für die Kommunikation und Datenerfassung zwischen allen Teilnehmer. 
Dazu gehören die drei Roboter, welche uns die Daten liefern wie LiDAR, Beschleunigungssensor etc., 
und das Frontend zu dem die Daten zur Visualisierung und Mitverfolgung gesendet werden 
und gegebenenfalls auch Befehle empfingt.

Weiters findet hier die Zentrale Datenverarbeitung und Verwaltung statt, 
dies ist verantwortlich für die Erstellung der LiDAR Map, 
der Ermittlung der Roboter Positionen 
und gegeben falls Berechnung der Messwerte. 
% im falle ineffizient etc

Und Steuerung der Roboter mithilfe eines Erkennungssystems 
welches bestimmte Kennzeichen in den erhaltenen Daten ausschau hält und 
darauf Kennzeichen für die einzelnen Bots erkennt und verfolgt, 
um entsprechend die Positionen aller Bots relativ zur LiDAR Map ausfindig zu machen.

Die Zentrale Datenverarbeitung und autonome Steuerung der Roboter sind 
im zu zeitigen Prototypen stand nicht implementiert.
% stattdessen weiterleitung und fernsteuerung
TODO 

TODO (Datenbank, Lidarmap)

Es wurde mit Python programmiert, 
% Gelaber über python
% wegen math Funktionen...
% schnelle Modifizierung 
% packet/ Bibliothek Fokussierung auf Einfachheit

\section{Datenverwaltung}
\label{subsec:backend_data}
% übersicht über die drei komponenten und wie ungefähr der datenfluss aussieht?
TODO
% Datenbank für lidar?
TODO

\section{Kommunikation}
\label{subsec:Kommunikation}
Die drei Roboter sind aktive Teilnehmer in der Kommunikation, 
das heißt es ist zu erwarten, dass die Verbindung konstant aufrechtzuerhalten ist,
bidirektional und dies auch in einem zeitlichen verhalten geschieht. 
Insofern muss weiter sichergestellt werden das ein konstanter Kommunikationsfluss ermöglicht bleibt.

Zur Verbindung entschieden wir uns für das Kommunikations-Protokoll Websocket, 
diese ermöglicht eine bidirektionale, persistente Verbindung zwischen einem Client und einem Server,
welches im Vergleich zu gewöhnlichen HTTP-Anfragen offen bleibt, wodurch Echtzeitkommunikation möglich ist.
% könnte man mehr ausschreiben aber schau ma später

\subsection{Python Packages}
% welche python packet verwendet wurden
\subsubsection{websockets}
Für Python ist ein Websocket Packet namens 'websockets' vorhanden welches die Client-Server Kommunikation
um ein Vielfaches vereinfacht da man sich keine Sorge über Handshakes, Ping Pongs, oder anderes verhalten
der Websocket Spezifikation, da es alles von dem Paket behandelt wird 
und man sich mehr auf die Applikation fokussieren kann. 
Es sind dennoch einige Parameter zum zur Verfügung gestellt zur Modifizierung, falls benötigt.
% code beispiele?

% erklärung zu den packet Webscoket
Websockets Standard Implementierung basiert auf asyncio.
%  
Asyncio ist die eingebaute Implementierung von Koroutinen in Python,
dies erlaubt das Schreiben von asynchronen Frameworks, 
öfters verwendet für I/O limitierte Netzwerk Codes.
% snippet zu asyncio, könnte mehr schreiben?
Alternative ist eine threading Implementierung verfügbar für Websockets, 
die üblichere Implementierung von mehreren Tasks, 
jedoch haben wir uns für den zum zeitigen Prototyp Entwicklung-Stand dagegen entschieden,
aufgrund der möglichen erweiterten Komplexität von Thread sicheren code Ausführung.
% warum nicht? kann später bei optimierungsmöglichkeiten erklärt werden
Eine Sans-I/O Implementierung ist auch vorhanden jedoch für dieses Projekt zurzeit irrelevant.

\subsubsection{protobuff}
% verhalten in python
% wie anders


\subsection{}
% übersichtsgrafik über teilnehmer und wie datenablauf funktioniert
% asyncio - warum
% main task überblick (server und drei clients) warum so aufgeteilt?
% subtask

% erklärung zu asyncio
Asyncio funktioniert, indem Tasks sich den Event loop nehmen und mit dem 'await' 
Befehl anderen tasks erlaubt sich den event loop zu nehmen, im vergleich zu üblichen multitasking
wo jeder task eine feste zeit zugeschrieben bekommt vom Betriebsystem.

TODO

% FIFO Queues
% Wichtigkeit nicht blockierendes verhalten um asynchrones workflow zu gewährleisten
Damit die Prozesse im Backend nicht gezwungen sind immer zu bearbeiten, 
wenn und falls Einkommen Nachrichten zu bearbeiten sind, 
wird der Empfang von Websockets abgekoppelt von den backend Logik.
Dafür wurden Queues, realisiert als FIFO, verwendet, also ein zwischen speicher 
wo die erhaltenen Daten von den Websockets landen, um dann entsprechen weiter zu bearbeiten.
Somit können wir einen Prozess starten, welches auf eingehende Nachrichten warten kann, 
während unser Backend andere Prozesse ausführt.
% kann mehr dazu schreiben
% ermöglicht auch sachen etc.

\section{Optimierungsmöglichkeiten}
\label{subsec:Optimierungsmöglichkeiten}
% uvloop - drop in replacement
% https://github.com/MagicStack/uvloop
uvloop ist ein schneller drop-in Ersetzung von der eingebauten asyncio event loop, 
dieser ist entsprechend in Cython entwickelt (Cython ist entsprechend Python aber als Performanten C code compiliert).
Ziel dieser Ersetzung ist es asyncio um einiges schneller zu machen aber nicht von der Referenz verhalten von asyncio abzuweichen. 
Als drop-in Ersetzung geht dies so weit dass, die Abweichungen als Fehler kategorisiert werden.
% TODO threading warum nicht streng nötig 
% (hauptsächlich limitiert über Wifi I/O nicht anzahl an geräten & )
% falls anzahl größer wird dann villeicht
% compelierung python code
Es ist möglich Python code genau so wie jedes andere Programm zu kompilieren,
jedoch ist dies standardmäßig nicht nötig da der Interpreter Cpython automatisch Python byte code kompeliert (in PYC Dateien).


\section{Steuerung der Roboter}
\label{subsec:backend_robot_detection}
TODO 
% spätester schritt weil funktionierende Strategie benötigt wird zur Erkennung
% Datenbank/ Datenbearbeitung