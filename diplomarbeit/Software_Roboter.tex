% Software Roboter (C++)
% Zuständig: Leander

\chapter{Software - Roboter}
\label{sec:software_robots}
Was die Ansteuerung der einzelnen Roboter angeht, folgen wir so gut wie möglich dem DRY-Prinzip (``Don't repeat yourself''),
um Redundanzen zu vermeiden und dadurch den Wartungsaufwand möglichst gering zu halten.

\section{Kameras}
\label{subsec:robots_cams}
Wir verwenden jeweils ein ESP32-CAM AI-Thinker Modul zur erweiterten
Fernüberwachung der Roboter.
%
Dieses verbindet sich über WLAN mit dem \texttt{IoT}-Netzwerk und bietet über HTTP einen MJPEG-Videostream an.
%
Die drei Videostreams (einer pro Roboter) werden dann im Web-Interface
zusätzlich zu den LiDAR-Umgebungsdaten angezeigt,
um das räumliche Vorstellungsvermögen der Benutzer zu unterstützen.
%
Die Videodaten werden also nicht automatisch verarbeitet und zur autonomen Steuerung verwendet,
sondern dienen nur als weiterer Input für die Bediener.
\begin{figure}[H]
    \includegraphics[width=0.7\textwidth, center]{img/cam_erstes_bild.png}
    \caption{Erstes empfangenes Bild der ESP32-CAM}
    \label{fig:cam_erstes_bild}
\end{figure}

\section{Core-Bibliothek}
\label{subec:robots_core}
Die Core-Bibliothek bildet eine weiter Abstrahierungsschicht zu den Funktionalitäten der Roboter-Hardware.
%
In unserem Modell stellt die Arduino-Bibliothek die erste Abstrahierungsschicht dar,
während die Code-Bibliothek diese weiter vereinfacht.
%
Durch diese Abstrahierung werden die Programme für die einzelnen Roboter um ein Vielfaches vereinfacht und dementsprechend übersichtlicher.
%
Wir können also die hier definierte Logik für jeden Roboter wiederverwenden,
anstatt drei mal fast genau das Gleiche zu programmieren.
%
Die Core-Bibliothek übernimmt alles von der WLAN-Verbindung,
über die Fernsteuerung per WebSockets,
bis hin zum Umschalten der einzelnen Pins zur Ansteuerung der Motortreiber.
%
Die Programmierung der einzelnen Roboter beschränkt sich also darauf,
die einzelnen Komponenten zu konfigurieren und miteinander zu verbinden.
%
Da Herr Gastgeber während der Projektwoche 2023/24 (Siehe Abschnitt \ref{sec:vorgeschichte}) bereits viel Zeit darin investiert hat,
die Bibliothek so modular und wiederverwendbar wie möglich zu gestalten,
konnten wir diese mit nur wenigen Modifikationen für unsere Diplomarbeit nutzen,
obwohl wir einen ganz anderen Hardwareaufbau verwenden.

\subsection{Module Allgemein}
\label{subsec:software_common_modules}
Wie schon erwähnt,
wurde die Core-Bibiliothek so modular wie nur möglich gestaltet,
um so viele Anwendungsfälle wie möglich abzudecken.
%
Jedes Modul implementiert eine der folgenden Klassen:
\begin{itemize}
    \item \texttt{Sensor}: Ein Sensor bzw. eine Sensorgruppe
    \item \texttt{Actor}: Ein Aktor bzw. eine Aktorgruppe
    \item \texttt{Interface}: Ein Interface zur Steuerung, z.B. WLAN
\end{itemize}
Theoretisch ist es damit möglich,
gemeinsame Funktionalität für alle Sensoren/Aktoren/Interfaces zu definieren,
wobei dies aber nicht tatsächlich realisiert wurde.
%
Jede dieser Klassen implementiert wiederum die Klasse \texttt{Module},
welche die folgenden Funktionen definiert:
\begin{itemize}
    \item \lstinline[language=c]|void init()|:
        Ähnlich wie \texttt{setup()} beim Arduino, nur im Kontext eines einzelnen Moduls.
        Wird verwendet um das Modul zu initialisieren.
    \item \lstinline[language=c]|void tick()|:
        Ähnlich wie \texttt{loop()} beim Arduino, nur im Kontext eines einzelnen Moduls.
        Sobald der Roboter alle Module fertig initialisiert hat,
        wird ständig durch ebendiese Module iteriert,
        wobei deren \texttt{tick()}-Funktionen aufgerufen werden. 
    \item \lstinline[language=c]|void terminate()|:
        Wird eigentlich nicht verwendet,
        da die meisten Module nicht zur mehrfachen Initialisierung gedacht sind.
        Im Sinne der Vollständigkeit gibt es trotzdem die Möglichkeit,
        diese Funktion zu implementieren.
\end{itemize}


\subsection{Robota}
Die Klasse \texttt{Robota}%
\footnote{Dieser Name wurde in der Anfangsphase des Projekts (Ende 2023) gewählt, 
        um Konflikte mit der veralteten ``Arduino Robot Library'',
        welche standardmäßig von der Arduino IDE inkludiert wird,
        zu vermeiden.
        %
        Seit dem Wechsel von der Arduino IDE auf PlatformIO stellt dieser potentielle Konflikt kein Problem mehr da}
ist für das Management der Module zuständig.
%
Hierzu gibt es drei Variablen, welche für die vollständige Funktion relevant sind:
\begin{itemize}
    \item \lstinline[language=c]|uint32_t ticks|:
        Eine globaler Zähler, welche einmal pro Tick ausgeführt wird.
        Dieser kann von Modulen verwendet werden, um bestimmte Tätigkeiten nur alle $n$ Ticks auszuführen.
        % TODO check if 100ns is realistic: ((2^32) - 1) / (t * (10^-9)) / (60 * 60 * 24 * 365.25)
        Bei einer durchschnittlichen Zeit von $t_{tick}=100ns$ pro Tick reichen 32 Bits aus,
        um die Roboter für etwas mehr als $t_{overflow}=1.36*10^{-9}$ Jahre zu betreiben,
        was für unsere Zwecke mehr als ausreichend sein sollte.
    \item \lstinline[language=c]|uint16_t moduleTypes[MAX_MODULE_AMOUNT]|:
        Hier wird Typeninformation zu den Modulen gespeichert.
        %
        Diese wird in den Funktionen \texttt{getModule} und \texttt{getFirstModule} verwendet,
        um die Module nach Typ zu filtern.
    \item \lstinline[language=c]|Module *modules[MAX_MODULE_AMOUNT]|:
        Dies ist die gesamte Liste an registrierten Modulen.
        %
        Mit \texttt{addModule} können Einträge hinzugefügt werden.
\end{itemize}
%TODO: Robota funktionen; insb. init() und tick()

\section{Guide}
\label{subsec:software_guide}
Die Software von \textit{Guide} ist in diesem Projekt in dem Sinne einzigartig,
dass,
zusätzlich zur Steuerung des Roboters selber,
die gemessen LiDAR-Werte empfangen,
aufbereitet,
und mit möglichst wenig Verzögerung an den Server weitergeleitet werden müssen.
%
Der Erfolg des ganzen Projekts ist also von der Verlässlichkeit dieser Software abhängig.
%
Abgesehen davon verhält sich der Guide eigentlich genau gleich wie Tamerlan und Bambi:
%
Befehle werden vom Server empfangen und ausgeführt,
Messwerte werden an den Server weitergeleitet.
%
Da auch die Aufbereitung der LiDAR-Daten bereits in der Core-Bibliothek realisiert wurde,
ist die Software für den Guide ebenso wie bei den anderen Robotern größtenteils Plug\&Play.

\section{Tamerlan}
\label{subsec:software_tamerlan}

\section{Bambi}
\label{subsec:software_bambi}
