% Software Roboter (C++)
% Zuständig: Leander

\chapter{Software - Roboter}
\label{sec:software_robots}
Was die Ansteuerung der einzelnen Roboter angeht, folgen wir so gut wie möglich dem DRY-Prinzip (``Don't repeat yourself''),
um Redundanzen zu vermeiden und dadurch den Wartungsaufwand möglichst gering zu halten.

\section{Kameras}
\label{subsec:robots_cams}
Wir verwenden jeweils ein ESP32-CAM AI-Thinker Modul zur erweiterten
Fernüberwachung der Roboter.
%
Dieses verbindet sich über WLAN mit dem \texttt{IoT}-Netzwerk und bietet über HTTP einen MJPEG-Videostream an.
%
Die drei Videostreams (einer pro Roboter) werden dann im Web-Interface
zusätzlich zu den LiDAR-Umgebungsdaten angezeigt,
um das räumliche Vorstellungsvermögen der Benutzer zu unterstützen.
%
Die Videodaten werden also nicht automatisch verarbeitet und zur autonomen Steuerung verwendet,
sondern dienen nur als weiterer Input für die Bediener.
\begin{figure}[H]
    \includegraphics[width=0.7\textwidth, center]{img/cam_erstes_bild.png}
    \caption{Erstes empfangenes Bild der ESP32-CAM}
    \label{fig:cam_erstes_bild}
\end{figure}

\section{Core-Bibliothek}
\label{subec:robots_core}
Die Core-Bibliothek bildet eine weiter Abstrahierungsschicht zu den Funktionalitäten der Roboter-Hardware.
%
In unserem Modell stellt die Arduino-Bibliothek die erste Abstrahierungsschicht dar,
während die Code-Bibliothek diese weiter vereinfacht.
%
Durch diese Abstrahierung werden die Programme für die einzelnen Roboter um ein Vielfaches vereinfacht und dementsprechend übersichtlicher.
%
Wir können also die hier definierte Logik für jeden Roboter wiederverwenden,
anstatt drei mal fast genau das Gleiche zu programmieren.
%
Die Core-Bibliothek übernimmt alles von der WLAN-Verbindung,
über die Fernsteuerung per WebSockets,
bis hin zum Umschalten der einzelnen Pins zur Ansteuerung der Motortreiber.
%
Die Programmierung der einzelnen Roboter beschränkt sich also darauf,
die einzelnen Komponenten zu konfigurieren und miteinander zu verbinden.
%
Da Herr Gastgeber während der Projektwoche 2023/24 (Siehe Abschnitt \ref{sec:vorgeschichte}) bereits viel Zeit darin investiert hat,
die Bibliothek so modular und wiederverwendbar wie möglich zu gestalten,
konnten wir diese mit nur wenigen Modifikationen für unsere Diplomarbeit nutzen,
obwohl wir einen ganz anderen Hardwareaufbau verwenden.

\subsection{Module Allgemein}
\label{subsec:software_common_modules}
Wie schon erwähnt,
wurde die Core-Bibiliothek so modular wie nur möglich gestaltet,
um so viele Anwendungsfälle wie möglich abzudecken.
%
Jedes Modul implementiert eine der folgenden Klassen:
\begin{itemize}
    \item \texttt{Sensor}: Ein Sensor bzw. eine Sensorgruppe
    \item \texttt{Actor}: Ein Aktor bzw. eine Aktorgruppe
    \item \texttt{Interface}: Ein Interface zur Steuerung, z.B. WLAN
\end{itemize}
Theoretisch ist es damit möglich,
gemeinsame Funktionalität für alle Sensoren/Aktoren/Interfaces zu definieren,
wobei dies aber nicht tatsächlich realisiert wurde.
%
Jede dieser Klassen implementiert wiederum die Klasse \texttt{Module},
welche die folgenden Funktionen definiert:
\begin{itemize}
    \item \lstinline[language=c]|void init()|:
        Ähnlich wie \texttt{setup()} beim Arduino, nur im Kontext eines einzelnen Moduls.
        Wird verwendet um das Modul zu initialisieren.
    \item \lstinline[language=c]|void tick()|:
        Ähnlich wie \texttt{loop()} beim Arduino, nur im Kontext eines einzelnen Moduls.
        Sobald der Roboter alle Module fertig initialisiert hat,
        wird ständig durch ebendiese Module iteriert,
        wobei deren \texttt{tick()}-Funktionen aufgerufen werden. 
    \item \lstinline[language=c]|void terminate()|:
        Wird eigentlich nicht verwendet,
        da die meisten Module nicht zur mehrfachen Initialisierung gedacht sind.
        Im Sinne der Vollständigkeit gibt es trotzdem die Möglichkeit,
        diese Funktion zu implementieren.
\end{itemize}


\subsection{Robota}
Die Klasse \texttt{Robota}%
\footnote{Dieser Name wurde in der Anfangsphase des Projekts (Ende 2023) gewählt, 
        um Konflikte mit der veralteten ``Arduino Robot Library'',
        welche standardmäßig von der Arduino IDE inkludiert wird,
        zu vermeiden.
        %
        Seit dem Wechsel von der Arduino IDE auf PlatformIO stellt dieser potentielle Konflikt kein Problem mehr da}
ist für das Management der Module zuständig.
%
Hierzu gibt es drei Variablen, welche für die vollständige Funktion relevant sind:
\begin{itemize}
    \item \lstinline[language=c]|uint32_t ticks|:
        Eine globaler Zähler, welche einmal pro Tick ausgeführt wird.
        Dieser kann von Modulen verwendet werden, um bestimmte Tätigkeiten nur alle $n$ Ticks auszuführen.
        % TODO check if 100ns is realistic: ((2^32) - 1) / (t * (10^-9)) / (60 * 60 * 24 * 365.25)
        Bei einer durchschnittlichen Zeit von $t_{tick}=100ns$ pro Tick reichen 32 Bits aus,
        um die Roboter für etwas mehr als $t_{overflow}=1.36*10^{-9}$ Jahre zu betreiben,
        was für unsere Zwecke mehr als ausreichend sein sollte.
    \item \lstinline[language=c]|uint16_t moduleTypes[MAX_MODULE_AMOUNT]|:
        Hier wird Typeninformation zu den Modulen gespeichert.
        %
        Diese wird in den Funktionen \texttt{getModule} und \texttt{getFirstModule} verwendet,
        um die Module nach Typ zu filtern.
    \item \lstinline[language=c]|Module *modules[MAX_MODULE_AMOUNT]|:
        Dies ist die gesamte Liste an registrierten Modulen.
        %
        Mit \texttt{addModule} können Einträge hinzugefügt werden.
\end{itemize}
%TODO: Robota funktionen; insb. init() und tick()

\subsection{Sensoren}
\subsubsection{LD20 LiDAR}
Der Code zum Auslesen des LiDAR-Sensors basiert auf zwei Informationsquellen zum Protokoll:
%
Die offizielle Dokumentation von youyeetoo \cite{youyeetoo-ld20},
und einer Arduino-Bibliothek namens LD14P\_RP2040 \cite{ld20-library},
welche sehr stark modifiziert wurde, um Teil des \textit{Robota}-Frameworks zu werden.

Die Daten des LiDARs werden über eine RS-232-Schnittstelle (230400 baud 8N1) ausgelesen.
%
Hierbei werden nur von Seiten des LiDARs Daten gesendet,
es gibt keine Möglichkeit diesen über die UART zu steuern.
%
Jede Nachricht beginnt mit einem Header-Byte \texttt{0x54},
gefolgt von einem Info-Byte,
welcher die Art des Pakets angibt.
\begin{table}[H]
    \centering
    \begin{tabular}{r|l}
    Info-Byte & Pakettyp   \\ \hline
    0x2C      & Sensordaten \\
    0xE0      & Systemstatus \\
    0x0F      & Herstellerinfos   
    \end{tabular}
    \caption{Pakettypen des LD20}
    \label{tab:ld20-packet-overview}
\end{table}
Jedes Paket ist von einem Prüfbyte zur Fehlererkennung mittels CRC\footnote{Cyclic Redundancy Check} gefolgt.
%
Nur Pakete mit Sensordaten werden tatsächlich verarbeitet,
alle anderen werden verworfen,
da sie für diesen Anwendungszweck nicht unbedingt nötig sind.
%
Ein Paket mit Sensordaten besteht (neben den oben beschriebenem Header, Info-Byte und CRC)
aus der Geschwindigkeit des Messkopfes,
dem Startwinkel der Messung,
12 Messpunkten,
dem Endwinkel der Messung,
und einem Zeitstempel.
%
Die Messpunkte selber bestehen nur aus der gemessenen Entfernung und Intensität;
der Winkel muss selber berechnet werden.
%
Bei allen Einträgen die mehr als einen Byte beanspruchen wird der niederwertigste Byte zuerst übertragen,
des Protokoll ist also little-endian,
was bedeutet das die Rohdaten direkt in den Arbeitsspeicher von z.B. einem Arduino oder ESP32 übernommen werden können.
\begin{table}[H]
    \centering
    \begin{tabular}{l|l|l}
    Name            & Typ           & Einheit  \\ \hline
    Header          & fixed 0x54    &   \\
    VerLen          & fixed 0x2C    &   \\
    Geschwindigkeit & UInt16        & deg/s \\
    Startwinkel     & UInt16        & 0.01°  \\
    Messdaten       & 12x Messdaten &    \\
    EndWinkel       & UInt16        & 0.01° \\
    Zeitstempel     & UInt16        & ms \\
    CRC             & 1 Byte        &
    \end{tabular}
    \caption{Paketformat des Messdatenpakets}
    \label{tab:ld20-measurement-packet}
\end{table}
\begin{table}[H]
    \centering
    \begin{tabular}{l|l|l}
    Name        & Typ       & Einheit   \\ \hline
    Distance    & UInt16    & mm        \\
    Intensity   & Uint8     &           \\ % Einheitslos
    \end{tabular}
    \caption{Format der rohen Messdaten}
    \label{tab:ld20-measurement-data}
\end{table}
Der Winkel einer einzelnen Messung kann mittels linearer Interpolation wie folgt berechnet werden:
\begin{equation}
    \alpha = \alpha_{s} + \frac{\alpha_{e}-\alpha_{s}}{n-1}*i = \alpha_{s} + \frac{\alpha_{e}-\alpha_{s}}{11}*i
\end{equation}
Hierbei ist $\alpha$ der Winkel einer einzelnen Messung,
während $\alpha_{s}$ und $\alpha_{e}$ respektive den Start- und Endwinkel der Messserie repräsentieren.
$n$ steht für die Anzahl an Messungen pro Messserie und ist bei uns konstant $12$,
weshalb $n-1$ auf $11$ vereinfacht werden kann. $i$ ist der nullbasierte Index der einzelnen Messung im Kontext der Messserie.







\subsubsection{Drehencoder}
\subsubsection{MPU6050}

\subsection{Aktoren}
\subsection{Interfaces}

\section{Guide}
\label{subsec:software_guide}
Die Software von \textit{Guide} ist in diesem Projekt in dem Sinne einzigartig,
dass,
zusätzlich zur Steuerung des Roboters selber,
die gemessen LiDAR-Werte empfangen,
aufbereitet,
und mit möglichst wenig Verzögerung an den Server weitergeleitet werden müssen.
%
Der Erfolg des ganzen Projekts ist also von der Verlässlichkeit dieser Software abhängig.
%
Abgesehen davon verhält sich der Guide eigentlich genau gleich wie Tamerlan und Bambi:
%
Befehle werden vom Server empfangen und ausgeführt,
Messwerte werden an den Server weitergeleitet.
%
Da auch die Aufbereitung der LiDAR-Daten bereits in der Core-Bibliothek realisiert wurde,
ist die Software für den Guide ebenso wie bei den anderen Robotern größtenteils Plug\&Play.

\section{Tamerlan}
\label{subsec:software_tamerlan}

\section{Bambi}
\label{subsec:software_bambi}
